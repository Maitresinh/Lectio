// Lectio Database Schema
// Enhanced Prisma schema for complete Glose-like functionality

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== AUTH MODELS (Auth.js v5) =====
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  name          String?
  image         String?
  emailVerified DateTime?
  password      String?   // For credentials provider
  
  // Auth.js fields
  accounts      Account[]
  sessions      Session[]
  
  // Custom fields
  role          UserRole  @default(READER)
  status        UserStatus @default(ACTIVE)
  
  // Hypothesis integration
  hypothesisId  String?   @unique
  hypothesisToken String?
  
  // Relations
  ownedGroups   Group[]   @relation("GroupOwner")
  memberships   GroupMember[]
  annotations   Annotation[]
  progress      ReadingProgress[]
  feedItems     FeedItem[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@map("users")
}

enum UserRole {
  READER
  MODERATOR
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

// ===== CORE MODELS =====
model Book {
  id          String   @id @default(cuid())
  title       String
  author      String?
  isbn        String?  @unique
  description String?
  coverUrl    String?
  
  // File information
  fileName    String
  filePath    String   // Local path or S3 URL
  fileSize    Int
  mimeType    String   // application/epub+zip or application/pdf
  
  // Metadata
  metadata    Json?    // EPUB/PDF specific metadata
  uploadedBy  String?
  
  // Status
  isActive    Boolean  @default(true)
  isPublic    Boolean  @default(true)
  
  // Relations
  groups      GroupBook[]
  annotations Annotation[]
  progress    ReadingProgress[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("books")
}

model Group {
  id          String   @id @default(cuid())
  name        String
  description String?
  slug        String   @unique // URL-friendly identifier
  
  // Configuration
  isActive    Boolean  @default(true)
  isPublic    Boolean  @default(false)
  maxMembers  Int      @default(50)
  
  // Time bounds
  startDate   DateTime?
  endDate     DateTime?
  expirationMode ExpirationMode @default(SOFT)
  
  // Hypothesis integration
  hypothesisGroupId String? @unique
  
  // Relations
  ownerId     String
  owner       User     @relation("GroupOwner", fields: [ownerId], references: [id])
  members     GroupMember[]
  books       GroupBook[]
  feedItems   FeedItem[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([slug])
  @@index([isActive, isPublic])
  @@map("groups")
}

enum ExpirationMode {
  SOFT  // Read-only after expiration
  HARD  // Completely inaccessible
}

model GroupMember {
  id        String    @id @default(cuid())
  userId    String
  groupId   String
  role      GroupRole @default(MEMBER)
  
  // Activity tracking
  joinedAt  DateTime  @default(now())
  lastActiveAt DateTime?
  
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  group     Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  @@unique([userId, groupId])
  @@map("group_members")
}

enum GroupRole {
  OWNER
  MODERATOR
  MEMBER
}

model GroupBook {
  id        String   @id @default(cuid())
  groupId   String
  bookId    String
  
  // Reading schedule
  isActive  Boolean  @default(true)
  startDate DateTime?
  endDate   DateTime?
  
  addedAt   DateTime @default(now())
  addedBy   String?
  
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, bookId])
  @@map("group_books")
}

// ===== ANNOTATION MODELS =====
model Annotation {
  id        String   @id @default(cuid())
  userId    String
  bookId    String
  groupId   String?
  
  // Hypothesis integration
  hypothesisId String? @unique
  
  // Content
  text      String   // Selected text
  content   String   // Annotation content
  
  // Position (CFI for EPUB, page for PDF)
  cfiRange  String?  // EPUB CFI
  pageNumber Int?    // PDF page
  position  Json?    // Additional positioning data
  
  // Visual
  color     AnnotationColor @default(YELLOW)
  type      AnnotationType @default(NOTE)
  
  // Privacy & moderation
  isPrivate Boolean  @default(false)
  isDeleted Boolean  @default(false)
  isReported Boolean @default(false)
  
  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  replies   AnnotationReply[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([bookId, groupId])
  @@index([userId])
  @@index([hypothesisId])
  @@map("annotations")
}

enum AnnotationColor {
  YELLOW
  BLUE
  GREEN
  RED
  PURPLE
  ORANGE
}

enum AnnotationType {
  HIGHLIGHT
  NOTE
  QUESTION
  DISCUSSION
}

model AnnotationReply {
  id           String     @id @default(cuid())
  annotationId String
  userId       String
  content      String
  
  // Hypothesis integration
  hypothesisId String?    @unique
  
  annotation   Annotation @relation(fields: [annotationId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  @@map("annotation_replies")
}

// ===== ACTIVITY FEED =====
model FeedItem {
  id        String    @id @default(cuid())
  groupId   String?
  userId    String
  
  type      FeedType
  content   Json      // Flexible content based on type
  metadata  Json?     // Additional metadata
  
  group     Group?    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime  @default(now())
  
  @@index([groupId, createdAt])
  @@index([userId, createdAt])
  @@map("feed_items")
}

enum FeedType {
  ANNOTATION_CREATED
  MEMBER_JOINED
  BOOK_ADDED
  DISCUSSION_STARTED
  MILESTONE_REACHED
  GROUP_CREATED
}

// ===== READING PROGRESS =====
model ReadingProgress {
  id          String    @id @default(cuid())
  userId      String
  bookId      String
  groupId     String?
  
  // Progress tracking
  currentCfi  String?   // EPUB position
  currentPage Int?      // PDF page
  percentage  Float     @default(0)
  
  // Time tracking
  totalTime   Int       @default(0) // seconds
  lastReadAt  DateTime?
  
  // Milestones
  isCompleted Boolean   @default(false)
  completedAt DateTime?
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book        Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  startedAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@unique([userId, bookId])
  @@index([groupId])
  @@map("reading_progress")
}